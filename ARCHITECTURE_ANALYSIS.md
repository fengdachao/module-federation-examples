# Module Federation 项目架构分析

## 目录
1. [项目概述](#项目概述)
2. [核心架构设计](#核心架构设计)
3. [代码共享机制](#代码共享机制)
4. [关键示例分析](#关键示例分析)
5. [架构模式图解](#架构模式图解)
6. [实现步骤指南](#实现步骤指南)
7. [最佳实践](#最佳实践)

---

## 项目概述

这是一个 **Module Federation** 示例集合库，包含 70+ 个不同场景的示例项目，涵盖：

| 类别 | 示例数量 | 主要技术栈 |
|------|----------|------------|
| 基础示例 | 5+ | React, Webpack |
| SSR示例 | 8+ | React 16/17/18, Node.js |
| 多框架混合 | 10+ | React + Vue + Angular |
| 动态远程加载 | 6+ | Runtime API |
| Vite 集成 | 5+ | Vite + MF |
| TypeScript | 8+ | TS + React |
| 生产级示例 | 10+ | Rspack, Modern.js |

---

## 核心架构设计

### 2.1 Module Federation 基础概念

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Module Federation 核心概念                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   ┌─────────────────┐         ┌─────────────────┐         ┌──────────────┐  │
│   │      Host       │         │     Remote      │         │    Shared    │  │
│   │   (消费者应用)   │◄───────►│   (提供者应用)   │◄───────►│   (共享模块)  │  │
│   └─────────────────┘         └─────────────────┘         └──────────────┘  │
│          │                           │                           │          │
│          │ remotes                   │ exposes                   │ shared   │
│          ▼                           ▼                           ▼          │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                        remoteEntry.js                               │   │
│   │           (运行时远程入口文件，包含模块映射和加载逻辑)                   │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 三种核心角色

```
┌────────────────────────────────────────────────────────────────────┐
│                         应用角色关系图                              │
├────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                        Shell/Host                            │   │
│  │                      (主应用/宿主)                            │   │
│  │  • 作为入口点加载其他远程应用                                  │   │
│  │  • 配置 remotes 声明要消费的远程模块                          │   │
│  │  • 通常运行在主端口 (如 :3000 或 :3001)                       │   │
│  └────────────────────────────┬────────────────────────────────┘   │
│                               │                                     │
│              ┌────────────────┼────────────────┐                   │
│              ▼                ▼                ▼                   │
│  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐          │
│  │   Remote 1    │  │   Remote 2    │  │   Remote 3    │          │
│  │  (远程应用1)   │  │  (远程应用2)   │  │  (远程应用3)   │          │
│  │               │  │               │  │               │          │
│  │ exposes:      │  │ exposes:      │  │ exposes:      │          │
│  │  ./Button     │  │  ./Widget     │  │  ./Chart      │          │
│  │  ./Card       │  │  ./Modal      │  │  ./Table      │          │
│  └───────────────┘  └───────────────┘  └───────────────┘          │
│                                                                     │
└────────────────────────────────────────────────────────────────────┘
```

### 2.3 双向联邦 (Bi-Directional)

```
┌────────────────────────────────────────────────────────────────────┐
│                       双向联邦架构                                  │
├────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   ┌──────────────────────┐    ◄────►    ┌──────────────────────┐   │
│   │       App 1          │              │       App 2          │   │
│   ├──────────────────────┤              ├──────────────────────┤   │
│   │                      │              │                      │   │
│   │  exposes:            │              │  exposes:            │   │
│   │    ./RedButton       │              │    ./BlueButton      │   │
│   │                      │──────────────│                      │   │
│   │  remotes:            │    共享依赖   │  remotes:            │   │
│   │    app2: BlueButton  │◄────────────►│    app1: RedButton   │   │
│   │                      │              │                      │   │
│   └──────────────────────┘              └──────────────────────┘   │
│                                                                     │
│   特点: 每个应用既是 Host 也是 Remote，可以互相消费对方暴露的模块     │
│                                                                     │
└────────────────────────────────────────────────────────────────────┘
```

---

## 代码共享机制

### 3.1 依赖共享策略

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          依赖共享机制详解                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   共享配置示例:                                                              │
│   ┌────────────────────────────────────────────────────────────────────┐    │
│   │  shared: {                                                          │    │
│   │    react: {                                                         │    │
│   │      singleton: true,          // 确保只有一个实例                    │    │
│   │      requiredVersion: '^18.0', // 版本要求                           │    │
│   │      eager: false,             // 异步加载                           │    │
│   │    },                                                               │    │
│   │    'react-dom': { singleton: true },                                │    │
│   │    lodash: {},                 // 可共享但不强制单例                   │    │
│   │  }                                                                  │    │
│   └────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│   共享策略类型:                                                              │
│   ┌───────────────────────────────────────────────────────────────────┐     │
│   │  1. Singleton 单例模式                                             │     │
│   │     ├── 适用: React, Vue 等框架                                    │     │
│   │     └── 确保整个应用只有一个实例，避免状态冲突                        │     │
│   │                                                                    │     │
│   │  2. Version Matching 版本匹配                                      │     │
│   │     ├── requiredVersion: 指定版本要求                              │     │
│   │     └── strictVersion: 严格版本匹配                                 │     │
│   │                                                                    │     │
│   │  3. Self-Healing 自愈机制                                          │     │
│   │     ├── 当 Host 没有提供依赖时，Remote 自动回退到自己的版本           │     │
│   │     └── 确保模块的独立运行能力                                       │     │
│   └───────────────────────────────────────────────────────────────────┘     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 运行时加载流程

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         远程模块加载流程                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   ① 用户访问 Host 应用                                                       │
│   │                                                                          │
│   ▼                                                                          │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  Host 应用初始化                                                     │   │
│   │  • 加载本地代码                                                       │   │
│   │  • 初始化 Module Federation Runtime                                  │   │
│   └────────────────────────────────┬────────────────────────────────────┘   │
│                                    │                                         │
│   ② 需要加载远程组件时              ▼                                         │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  请求远程 remoteEntry.js                                             │   │
│   │  例: http://localhost:3002/remoteEntry.js                            │   │
│   └────────────────────────────────┬────────────────────────────────────┘   │
│                                    │                                         │
│   ③ 远程应用响应                   ▼                                         │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  remoteEntry.js 包含:                                                │   │
│   │  • 模块映射表 (exposes)                                               │   │
│   │  • 共享依赖信息                                                       │   │
│   │  • 异步加载函数                                                       │   │
│   └────────────────────────────────┬────────────────────────────────────┘   │
│                                    │                                         │
│   ④ 协商共享依赖                   ▼                                         │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  Share Scope 协商                                                    │   │
│   │  • 检查 Host 是否已有相同版本的依赖                                    │   │
│   │  • 决定使用 Host 还是 Remote 的依赖                                   │   │
│   │  • Singleton 模块确保只加载一次                                        │   │
│   └────────────────────────────────┬────────────────────────────────────┘   │
│                                    │                                         │
│   ⑤ 加载目标模块                   ▼                                         │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  按需加载组件代码块                                                   │   │
│   │  例: 加载 ./Button 对应的 chunk                                      │   │
│   └────────────────────────────────┬────────────────────────────────────┘   │
│                                    │                                         │
│   ⑥ 渲染远程组件                   ▼                                         │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  远程组件在 Host 中渲染                                              │   │
│   │  使用协商好的共享依赖                                                  │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 关键示例分析

### 4.1 基础 Host-Remote 模式

**目录结构:**
```
basic-host-remote/
├── app1/               # Host 应用 (消费者)
│   ├── modern.config.js
│   └── src/routes/page.jsx
├── app2/               # Remote 应用 (提供者)
│   ├── modern.config.js
│   └── src/components/button.js
└── package.json
```

**Host 配置 (app1/modern.config.js):**
```javascript
new ModuleFederationPlugin({
  name: 'app1',
  remotes: {
    app2: 'app2@http://localhost:3002/static/js/remoteEntry.js',
  },
  shared: {
    react: { singleton: true },
    'react-dom': { singleton: true },
  },
})
```

**Remote 配置 (app2/modern.config.js):**
```javascript
new ModuleFederationPlugin({
  name: 'app2',
  filename: 'static/js/remoteEntry.js',
  exposes: {
    './Button': './src/components/button.js',
  },
  shared: {
    react: { singleton: true },
    'react-dom': { singleton: true },
  },
})
```

**使用远程组件:**
```jsx
// app1 中使用 app2 的 Button
import Button from 'app2/Button';

const Page = () => (
  <div>
    <h1>Host Application</h1>
    <Button />  {/* 来自远程 app2 的组件 */}
  </div>
);
```

### 4.2 嵌套远程加载

```
┌────────────────────────────────────────────────────────────────────┐
│                       嵌套远程架构                                  │
├────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   ┌─────────────┐      ┌─────────────┐      ┌─────────────┐        │
│   │    App1     │─────►│    App2     │─────►│    App3     │        │
│   │   (Host)    │      │  (Remote/   │      │   (Remote)  │        │
│   │             │      │   Host)     │      │             │        │
│   │ 消费 app2   │      │ 消费 app3   │      │ 提供 Button │        │
│   └─────────────┘      └─────────────┘      └─────────────┘        │
│                                                                     │
│   App1 请求 ButtonContainer → App2 请求 Button → App3 提供 Button   │
│                                                                     │
│   形成模块依赖链: App1 → App2 → App3                                │
│                                                                     │
└────────────────────────────────────────────────────────────────────┘
```

### 4.3 动态远程加载

**运行时动态加载 (使用 @module-federation/runtime):**
```typescript
import { init, loadRemote } from '@module-federation/runtime';

// 初始化运行时
init({
  name: 'app1',
  remotes: [
    { name: 'app2', entry: 'http://localhost:3002/remoteEntry.js' },
    { name: 'app3', entry: 'http://localhost:3003/remoteEntry.js' },
  ],
});

// 动态加载远程模块
const Widget = await loadRemote('app2/Widget');
```

### 4.4 跨框架共享

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          跨框架共享架构                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   ┌──────────────────────────────────────────────────────────────────────┐  │
│   │                         Shell (React Host)                            │  │
│   │                              Port: 3001                               │  │
│   └──────────────────────────────────┬───────────────────────────────────┘  │
│                                      │                                       │
│           ┌──────────────────────────┼──────────────────────────┐           │
│           │                          │                          │           │
│           ▼                          ▼                          ▼           │
│   ┌───────────────┐          ┌───────────────┐          ┌───────────────┐   │
│   │ React Counter │          │ Shared Store  │          │  Vue Counter  │   │
│   │   Port: 3002  │          │  Port: 3003   │          │   Port: 3004  │   │
│   │               │◄────────►│               │◄────────►│               │   │
│   │ effector-react│          │   effector    │          │ effector-vue  │   │
│   └───────────────┘          └───────────────┘          └───────────────┘   │
│                                                                              │
│   共享状态管理: 使用 Effector 作为框架无关的状态库                             │
│   React 和 Vue 组件共享同一个状态存储                                         │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.5 SSR (服务端渲染) 架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           SSR Federation 架构                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │                           Shell Server                               │   │
│   │                           (Node.js SSR)                              │   │
│   │   • 服务端渲染 HTML                                                   │   │
│   │   • 使用 UniversalFederationPlugin                                   │   │
│   │   • 同时消费客户端和服务端远程模块                                      │   │
│   └────────────────────────────────┬────────────────────────────────────┘   │
│                                    │                                         │
│              ┌─────────────────────┼─────────────────────┐                  │
│              │                     │                     │                  │
│              ▼                     ▼                     ▼                  │
│   ┌───────────────────┐ ┌───────────────────┐ ┌───────────────────┐        │
│   │   Remote1 Client  │ │   Remote1 Server  │ │      Remote2      │        │
│   │   /client/        │ │   /server/        │ │ (Client + Server) │        │
│   │  remoteEntry.js   │ │  remoteEntry.js   │ │                   │        │
│   └───────────────────┘ └───────────────────┘ └───────────────────┘        │
│                                                                              │
│   配置示例:                                                                  │
│   ┌─────────────────────────────────────────────────────────────────────┐   │
│   │  // 客户端配置                                                       │   │
│   │  new ModuleFederationPlugin({                                        │   │
│   │    name: 'shell',                                                    │   │
│   │    remotes: {                                                        │   │
│   │      remote1: 'remote1@http://localhost:3001/client/remoteEntry.js', │   │
│   │    },                                                                │   │
│   │  })                                                                  │   │
│   │                                                                      │   │
│   │  // 服务端配置                                                        │   │
│   │  new UniversalFederationPlugin({                                     │   │
│   │    isServer: true,                                                   │   │
│   │    library: { type: 'commonjs-module' },                             │   │
│   │    remotes: {                                                        │   │
│   │      remote1: 'remote1@http://localhost:3001/server/remoteEntry.js', │   │
│   │    },                                                                │   │
│   │  })                                                                  │   │
│   └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 架构模式图解

### 5.1 整体项目架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     Module Federation Examples 项目架构                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                          示例分类                                    │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌──────────────────┐ ┌──────────────────┐ ┌──────────────────┐            │
│  │   基础示例        │ │   高级 API       │ │   框架集成        │            │
│  ├──────────────────┤ ├──────────────────┤ ├──────────────────┤            │
│  │ • basic-host-    │ │ • dynamic-       │ │ • vue3-demo     │            │
│  │   remote         │ │   remotes        │ │ • angular-      │            │
│  │ • bi-directional │ │ • runtime-       │ │   universal-ssr │            │
│  │ • nested-remote  │ │   plugins        │ │ • react-in-vue  │            │
│  │ • self-healing   │ │ • automatic-     │ │ • quasar-cli    │            │
│  └──────────────────┘ │   vendor-sharing │ └──────────────────┘            │
│                       └──────────────────┘                                   │
│                                                                              │
│  ┌──────────────────┐ ┌──────────────────┐ ┌──────────────────┐            │
│  │   SSR 示例        │ │   构建工具        │ │   生产级示例      │            │
│  ├──────────────────┤ ├──────────────────┤ ├──────────────────┤            │
│  │ • react-18-ssr   │ │ • module-        │ │ • modernjs       │            │
│  │ • nextjs-ssr     │ │   federation-    │ │ • dashboard-     │            │
│  │ • server-side-   │ │   vite-react     │ │   admin          │            │
│  │   rendering      │ │ • rspack-webpack │ │ • cloud          │            │
│  │ • angular-       │ │   -interop       │ │ • typescript-    │            │
│  │   universal-ssr  │ │ • rspack_hmr     │ │   monorepo       │            │
│  └──────────────────┘ └──────────────────┘ └──────────────────┘            │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                        测试 & 工具                                   │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │  • playwright-e2e/     E2E 测试框架配置                              │    │
│  │  • cypress-e2e/        Cypress 测试示例                              │    │
│  │  • scripts/            构建脚本                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 5.2 技术栈覆盖

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         技术栈全景图                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│   构建工具                    框架                         运行时             │
│   ┌────────────┐            ┌────────────┐            ┌────────────┐        │
│   │  Webpack   │            │   React    │            │   Browser  │        │
│   │  Rspack    │            │   Vue 2/3  │            │   Node.js  │        │
│   │  Vite      │            │  Angular   │            │   Edge SSR │        │
│   │  Modern.js │            │  Svelte    │            │            │        │
│   │  Next.js   │            │  Solid.js  │            │            │        │
│   │  Remix     │            │  Preact    │            │            │        │
│   └────────────┘            └────────────┘            └────────────┘        │
│         │                         │                         │               │
│         └─────────────────────────┼─────────────────────────┘               │
│                                   │                                          │
│                                   ▼                                          │
│                     ┌─────────────────────────────┐                         │
│                     │    @module-federation/      │                         │
│                     │         enhanced            │                         │
│                     │           │                 │                         │
│                     │           ▼                 │                         │
│                     │  ┌─────────────────────┐    │                         │
│                     │  │ ModuleFederationPlugin│   │                         │
│                     │  │ UniversalFederation  │    │                         │
│                     │  │ Runtime API          │    │                         │
│                     │  └─────────────────────┘    │                         │
│                     └─────────────────────────────┘                         │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 实现步骤指南

### 6.1 从零开始实现 Module Federation

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    实现 Module Federation 的 6 个步骤                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Step 1: 项目规划                                                            │
│  ═════════════════                                                          │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  • 确定应用边界: 哪些是 Host，哪些是 Remote                           │    │
│  │  • 识别共享模块: 公共组件、工具函数、状态管理                           │    │
│  │  • 规划端口分配: 每个应用独立端口                                      │    │
│  │  • 确定共享依赖: React, Vue 等框架级依赖                              │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                    │                                         │
│                                    ▼                                         │
│  Step 2: 创建 Remote 应用                                                    │
│  ═══════════════════════                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  mkdir remote-app && cd remote-app                                   │    │
│  │  npm init -y                                                         │    │
│  │  npm install webpack webpack-cli @module-federation/enhanced         │    │
│  │                                                                      │    │
│  │  // webpack.config.js                                                │    │
│  │  new ModuleFederationPlugin({                                        │    │
│  │    name: 'remoteApp',                                                │    │
│  │    filename: 'remoteEntry.js',                                       │    │
│  │    exposes: {                                                        │    │
│  │      './Button': './src/Button',                                     │    │
│  │      './Card': './src/Card',                                         │    │
│  │    },                                                                │    │
│  │    shared: { react: { singleton: true } },                           │    │
│  │  })                                                                  │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                    │                                         │
│                                    ▼                                         │
│  Step 3: 创建 Host 应用                                                      │
│  ══════════════════════                                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  mkdir host-app && cd host-app                                       │    │
│  │  npm init -y                                                         │    │
│  │  npm install webpack webpack-cli @module-federation/enhanced         │    │
│  │                                                                      │    │
│  │  // webpack.config.js                                                │    │
│  │  new ModuleFederationPlugin({                                        │    │
│  │    name: 'hostApp',                                                  │    │
│  │    remotes: {                                                        │    │
│  │      remoteApp: 'remoteApp@http://localhost:3002/remoteEntry.js',    │    │
│  │    },                                                                │    │
│  │    shared: { react: { singleton: true } },                           │    │
│  │  })                                                                  │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                    │                                         │
│                                    ▼                                         │
│  Step 4: 配置异步边界                                                        │
│  ═══════════════════                                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  // src/index.js (入口文件)                                          │    │
│  │  import('./bootstrap');  // 异步加载主应用                            │    │
│  │                                                                      │    │
│  │  // src/bootstrap.js (实际应用代码)                                   │    │
│  │  import React from 'react';                                          │    │
│  │  import ReactDOM from 'react-dom';                                   │    │
│  │  import App from './App';                                            │    │
│  │  ReactDOM.render(<App />, document.getElementById('root'));          │    │
│  │                                                                      │    │
│  │  ⚠️ 异步边界是必需的，让 webpack 在加载主代码前协商共享依赖              │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                    │                                         │
│                                    ▼                                         │
│  Step 5: 使用远程组件                                                        │
│  ═══════════════════                                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  // Host 应用中使用 Remote 组件                                       │    │
│  │  import React, { Suspense, lazy } from 'react';                      │    │
│  │                                                                      │    │
│  │  // 方式1: 静态导入 (需要类型声明)                                     │    │
│  │  import Button from 'remoteApp/Button';                              │    │
│  │                                                                      │    │
│  │  // 方式2: 动态导入 (推荐)                                            │    │
│  │  const Button = lazy(() => import('remoteApp/Button'));              │    │
│  │                                                                      │    │
│  │  function App() {                                                    │    │
│  │    return (                                                          │    │
│  │      <Suspense fallback={<div>Loading...</div>}>                     │    │
│  │        <Button />                                                    │    │
│  │      </Suspense>                                                     │    │
│  │    );                                                                │    │
│  │  }                                                                   │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                    │                                         │
│                                    ▼                                         │
│  Step 6: 测试与部署                                                          │
│  ═════════════════                                                          │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  本地测试:                                                           │    │
│  │  1. 启动 Remote: cd remote-app && npm start (port 3002)              │    │
│  │  2. 启动 Host: cd host-app && npm start (port 3001)                  │    │
│  │  3. 访问 http://localhost:3001                                       │    │
│  │                                                                      │    │
│  │  生产部署:                                                            │    │
│  │  • 为每个应用配置独立的 CDN 或服务器                                   │    │
│  │  • 更新 remotes URL 为生产环境地址                                    │    │
│  │  • 配置 CORS 头允许跨域请求                                           │    │
│  │  • 考虑版本控制和缓存策略                                             │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 6.2 完整配置示例

**Remote 应用 (webpack.config.js):**
```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin');
const { ModuleFederationPlugin } = require('@module-federation/enhanced');
const deps = require('./package.json').dependencies;

module.exports = {
  entry: './src/index',
  mode: 'development',
  devServer: {
    port: 3002,
    headers: {
      'Access-Control-Allow-Origin': '*',  // 允许跨域
    },
  },
  output: {
    publicPath: 'auto',  // 自动推断公共路径
  },
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        loader: 'babel-loader',
        exclude: /node_modules/,
        options: {
          presets: ['@babel/preset-react'],
        },
      },
    ],
  },
  plugins: [
    new ModuleFederationPlugin({
      name: 'remoteApp',           // 应用名称 (全局唯一)
      filename: 'remoteEntry.js',  // 远程入口文件名
      exposes: {                   // 暴露的模块
        './Button': './src/components/Button',
        './Card': './src/components/Card',
      },
      shared: {                    // 共享依赖配置
        react: {
          singleton: true,
          requiredVersion: deps.react,
        },
        'react-dom': {
          singleton: true,
          requiredVersion: deps['react-dom'],
        },
      },
    }),
    new HtmlWebpackPlugin({
      template: './public/index.html',
    }),
  ],
};
```

**Host 应用 (webpack.config.js):**
```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin');
const { ModuleFederationPlugin } = require('@module-federation/enhanced');
const deps = require('./package.json').dependencies;

module.exports = {
  entry: './src/index',
  mode: 'development',
  devServer: {
    port: 3001,
  },
  output: {
    publicPath: 'auto',
  },
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        loader: 'babel-loader',
        exclude: /node_modules/,
        options: {
          presets: ['@babel/preset-react'],
        },
      },
    ],
  },
  plugins: [
    new ModuleFederationPlugin({
      name: 'hostApp',
      remotes: {
        // 格式: 'scope@远程入口URL'
        remoteApp: 'remoteApp@http://localhost:3002/remoteEntry.js',
      },
      shared: {
        react: {
          singleton: true,
          requiredVersion: deps.react,
        },
        'react-dom': {
          singleton: true,
          requiredVersion: deps['react-dom'],
        },
      },
    }),
    new HtmlWebpackPlugin({
      template: './public/index.html',
    }),
  ],
};
```

---

## 最佳实践

### 7.1 错误处理与回退

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          错误处理策略                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  1. React Error Boundary                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  class RemoteErrorBoundary extends React.Component {                 │    │
│  │    state = { hasError: false };                                      │    │
│  │                                                                      │    │
│  │    static getDerivedStateFromError() {                               │    │
│  │      return { hasError: true };                                      │    │
│  │    }                                                                 │    │
│  │                                                                      │    │
│  │    render() {                                                        │    │
│  │      if (this.state.hasError) {                                      │    │
│  │        return <FallbackComponent />;  // 显示本地回退组件             │    │
│  │      }                                                               │    │
│  │      return this.props.children;                                     │    │
│  │    }                                                                 │    │
│  │  }                                                                   │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  2. Runtime 重试机制                                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  init({                                                              │    │
│  │    name: 'host',                                                     │    │
│  │    plugins: [                                                        │    │
│  │      {                                                               │    │
│  │        name: 'retry-plugin',                                         │    │
│  │        errorLoadRemote: async (args) => {                            │    │
│  │          // 重试逻辑                                                  │    │
│  │          return retry(args, 3);  // 重试 3 次                         │    │
│  │        },                                                            │    │
│  │      },                                                              │    │
│  │    ],                                                                │    │
│  │  });                                                                 │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 7.2 性能优化

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          性能优化策略                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ✅ 推荐做法                          ❌ 避免做法                            │
│  ───────────────────────────────────  ───────────────────────────────────   │
│  • 懒加载远程组件                      • 同步导入所有远程模块                  │
│  • 使用 singleton 共享框架             • 重复打包相同依赖                     │
│  • 预加载关键路由组件                   • 忽略版本兼容性检查                   │
│  • 配置合理的缓存策略                   • 大量小模块暴露                       │
│  • 按路由分割远程应用                   • 循环依赖                            │
│                                                                              │
│  预加载策略:                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  // 在用户可能需要时提前加载                                          │    │
│  │  const preloadRemote = () => {                                       │    │
│  │    import(/* webpackPrefetch: true */ 'remoteApp/HeavyComponent');   │    │
│  │  };                                                                  │    │
│  │                                                                      │    │
│  │  // 或使用 Runtime API                                                │    │
│  │  import { preloadRemote } from '@module-federation/runtime';         │    │
│  │  preloadRemote([{ nameOrAlias: 'remoteApp', expose: './Widget' }]);  │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 7.3 TypeScript 支持

```typescript
// 类型声明文件 (types/remotes.d.ts)
declare module 'remoteApp/Button' {
  import { FC } from 'react';
  interface ButtonProps {
    onClick?: () => void;
    children?: React.ReactNode;
  }
  const Button: FC<ButtonProps>;
  export default Button;
}

// 或使用 @module-federation/enhanced 的自动类型生成
new ModuleFederationPlugin({
  name: 'remoteApp',
  dts: {
    generateTypes: true,  // 自动生成类型定义
  },
  // ...
});
```

---

## 总结

Module Federation 提供了一种强大的微前端架构解决方案：

| 特性 | 优势 |
|------|------|
| **代码共享** | 运行时共享依赖，避免重复加载 |
| **独立部署** | 各应用独立开发、构建、部署 |
| **框架无关** | 支持 React、Vue、Angular 等混合使用 |
| **动态加载** | 按需加载远程模块，优化首屏性能 |
| **版本管理** | 灵活的版本协商和自愈机制 |
| **SSR 支持** | 客户端和服务端统一的联邦方案 |

选择此架构的场景：
- 大型应用需要拆分为独立团队负责的子应用
- 需要跨应用共享组件或业务逻辑
- 渐进式将单体应用迁移到微前端
- 需要支持多框架技术栈共存
